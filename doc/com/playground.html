<template files.array="[]" height.int="30" class="shadow">
  <meta name="scope" cur.int="1" />
  <meta name="module" pkg="lodash.debounce" cjs />

  <style>
    :host {
      display: flex;
      flex-direction: column;
      height: ":${height}em";
      border-radius: 5px;
      overflow: hidden;
      background-color: "$$color.bg.l5_";
    }
    #demo {
      display: block;
      overflow: hidden;
      border: none;
      padding: 0;
      margin: 0;
    }
    #url {
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      font-size: 0.6em;
      font-weight: 300;
    }
    #title {
      padding: 0.2em;
      display: flex;
      background-color: "$$color.bgr";
      color: "$$color.textr";
    }
    #title > * {
      padding: 0 0.1em;
    }
  </style>
  <div id="title">
    <wcex-ui.icon style="margin: 0 0.3em" icon="airplay" size="1"></wcex-ui.icon>
    <div>PLAYGROUND</div>

    <div id="url" style="flex: 1; text-align: center" $>files[0]</div>
    <wcex-ui.icon
      title="reload"
      icon="replay_circle_filled"
      $color="$color.sec"
      active
      size="1"
      @click="loadDemo()"
    ></wcex-ui.icon>
    <wcex-ui.icon
      title="reset"
      icon="delete_forever"
      $color="$color.sec"
      active
      size="1"
      @click="resetCache()"
    ></wcex-ui.icon>
  </div>
  <!-- 示例区域 -->

  <iframe id="demo"></iframe>
  <!-- 编辑器 -->
  <wcex-ui.tab $tabs="files" style="flex: 1" $$="cur" @change.1="$emit('update',$id['ed'+value])">
    <div slot="panel" style="height: 100%" class="column">
      <wcex-ui.monaco
        style="height: 100%"
        :id="ed${index}"
        $for="files"
        $file="readyFlag?playgroundPath(value):''"
        $show="(cur==index)?'panel':''"
        $fn="debounce((ev)=>onEdit(ev),1000,{leading:false,trailing:true})"
        @edit="fn($ev)"
      ></wcex-ui.monaco>
    </div>
  </wcex-ui.tab>
  <script scope="debounce" src="lodash.debounce" nocall></script>

  <script scope=".">
    // 注意开发时iframe配置的同源问题,需要使用localhost访问
    return class {
      readyFlag = 0;
      baseUrl = "";
      lang = "";
      async onReady() {
        this.baseUrl = this.$router.route.default.attrs.url;
        this.lang = this.$router.route.default.attrs.lang;
        await this.loadDemo();
        this.readyFlag = 1;
        this.$monitSize(this.$rootElem, () => {
          console.log("size--Changed");
          // 通知编辑器重新布局
          for (let i = 0; i < this.files.length; i++) {
            this.$emit("update", this.$id["ed" + i]);
          }
        });
      }

      docPath(path) {
        return decodeURI(this.$path("../guide/" + this.lang + "/" + this.baseUrl.replace(/\/.*$/, "/") + path));
      }
      playgroundPath(path) {
        if (path && this.baseUrl) {
          return decodeURI(`${location.origin}/__playground/${this.baseUrl}/${path}`);
        }
      }
      async swPost(type, data) {
        (await navigator.serviceWorker.getRegistration("/")).active.postMessage({
          type,
          data,
        });
      }
      async updateDemo(file) {
        let mainFile = this.playgroundPath(this.files[0]);
        if (file && file != mainFile) {
          //获取主index.html路径
          let p = mainFile.replace(/^(.*\/).*?$/, "$1");
          let f = file.replace(p, "");
          // 热更新
          this.$id.demo.contentWindow.dispatchEvent(new CustomEvent("wc-hotload", { detail: { path: f } }));
        } else {
          // 重新load
          this.$id.demo.contentWindow.location.reload();
        }
      }
      async onEdit(ev) {
        if (ev) {
          // 向sw发送消息,更新缓存
          await this.swPost("hotCacheSet", {
            file: ev.detail.file,
            text: ev.detail.text,
          });
          await this.updateDemo(ev.detail.file);
        }
      }
      async loadDemo() {
        if (!this.baseUrl) return;
        // 加载数据
        let loadFiles = await Promise.all(
          this.files.map((f) => {
            return fetch(this.docPath(f))
              .then((r) => {
                return r.text();
              })
              .then((v) => {
                return {
                  url: this.playgroundPath(f),
                  text: v,
                };
              });
          })
        );

        // 更新缓存
        for (let f of loadFiles) {
          await this.swPost("hotCacheSet", {
            file: f.url,
            text: f.text,
          });
        }

        this.$id.demo.src = loadFiles[0].url;
      }
      async resetCache() {
        await this.swPost("hotCacheClean", {});

        await this.loadDemo();
        // 通知编辑器重新加载
        for (let i = 0; i < this.files.length; i++) {
          this.$emit("reload", this.$id["ed" + i]);
        }
      }
    };
  </script>
</template>
